#!/usr/bin/env python
import os
import shutil

import logging
logger = logging.getLogger(__name__)


def walk(root):
    # flatten into just all the full filepaths
    for dirpath, dirnames, filenames in os.walk(root):
        for filename in filenames:
            yield os.path.join(dirpath, filename)


def seek_to_beginning_of_final_whitespace(fp, max_offset=None):
    # jump to EOF
    fp.seek(0, 2)
    if max_offset is None:
        max_offset = fp.tell()
    # find location of last non-whitespace character by starting at the end and working backward
    for offset in range(1, max_offset):
        # if the second argument of seek is 2, first argument is relative to the end of the file
        fp.seek(-offset, 2)
        char = fp.read(1)
        if not char.isspace():
            # we just read over the last non-whitespace character, so the
            # current file position is now at the first of the final whitespace
            return


def public(obj):
    for name, value in vars(obj).items():
        if not name.startswith('_'):
            yield name, value


class Test(object):
    '''Each Test.method returns True if the given file violates the test'''
    def trailing_whitespace(filepath):
        errors = 0
        with open(filepath) as fp:
            for lineno, line in enumerate(fp, 1):
                if line.rstrip('\n').endswith((' ', '\t')):
                    errors += 1
                    logger.warn('%s:%d: trailing whitespace', filepath, lineno)

        return errors > 0

    def single_newline_at_eof(filepath):
        with open(filepath) as fp:
            seek_to_beginning_of_final_whitespace(fp)
            # fp is now sitting at the beginning of the final whitespace, if any, in the file.
            #   if there is none, fp.tell() == size
            # the rest of the file should be a single newline:
            return fp.read() != '\n'


class Fix(object):
    def trailing_whitespace(filepath):
        # use a temporary file so we don't lose anything if it breaks
        filepath_tmp = filepath + '.tmp'
        with open(filepath, 'r') as file_in, open(filepath_tmp, 'w') as file_out:
            for line in file_in:
                file_out.write(line.rstrip() + '\n')
        # copy metadata from the original before we write over it
        shutil.copystat(filepath, filepath_tmp)
        # and a simple rename to finalize the changes
        os.rename(filepath_tmp, filepath)

    def single_newline_at_eof(filepath):
        # much the same as
        with open(filepath, 'a+') as fp:
            seek_to_beginning_of_final_whitespace(fp)
            fp.write('\n')
            # from the file.truncate documentation:
            #   Size defaults to the current file position, as returned by tell()
            fp.truncate()


def test(root):
    for filepath in walk(root):
        for check, method in public(Test):
            failed = method(filepath)
            if failed:
                logger.error('%s failed %s test', filepath, check)
            else:
                logger.debug('%s passed %s test', filepath, check)


def fix(root):
    for filepath in walk(root):
        for check, method in public(Test):
            logger.error('fixing %s for %s', filepath, check)
            method(filepath)


def main():
    import argparse
    parser = argparse.ArgumentParser(description='Test or apply styles',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('files', nargs='+', help='Files / directories to read', default='.')
    parser.add_argument('--verbose', action='store_true', help='Print extra information')
    opts = parser.parse_args()

    # DEBUG=10, WARN=30
    level = logging.DEBUG if opts.verbose else logging.WARN
    logging.basicConfig(level=level)

    for file_or_dir in opts.files:
        test(file_or_dir)

if __name__ == '__main__':
    main()
