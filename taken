#!/usr/bin/env python
import re
import sys
import argparse
import subprocess
import socket
import urllib

import redis

redis_client = redis.StrictRedis()
whois_quota_exceeded = re.compile('(WHOIS LIMIT EXCEEDED|quota exceeded)')


def responds_to_http(domain):
    try:
        urllib.urlopen('http://' + domain)
        return True
    except IOError:
        return False


def has_dns_a_record(domain):
    try:
        socket.gethostbyname(domain)
        return True
    except socket.gaierror:
        return False


def whois(domain):
    redis_key = 'whois:%s' % domain
    cached = redis_client.get(redis_key)
    if not cached or whois_quota_exceeded.search(cached):
        # print >> sys.stderr, '$ whois ' + domain
        cached = subprocess.check_output(['whois', domain])
        redis_client.set(redis_key, cached)
        redis_client.expire(redis_key, 24*60*60)  # cache for 24h
    return cached


def is_taken_in_whois(domain):
    result = whois(domain)
    if 'Status: Active' in result:
        return True
    elif 'Status: Locked' in result:
        return True
    elif 'Status: Not Registered' in result:
        return False
    else:
        raise Exception('Could not retrieve status from whois: ' + result)


def get_status(domain):
    if responds_to_http(domain) or has_dns_a_record(domain):
        return 'taken'
    else:
        try:
            if is_taken_in_whois(domain):
                return 'taken'
            else:
                return 'available'
        except Exception:
            return 'maybe'


class Domain(object):
    def __init__(self, name):
        self.name = name

    def __str__(self):
        status = get_status(self.name)
        return status + '\t' + self.name


def main():
    parser = argparse.ArgumentParser(description='whois check.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    # parser.add_argument('domains', nargs='?', type=argparse.FileType('r'), default=sys.stdin)
    # opts = parser.parse_args()

    if sys.stdin.isatty():
        print >> sys.stderr, 'you must pipe in a list of domains separated by newlines'
        exit(1)

    domains = [Domain(line.strip()) for line in sys.stdin]
    for domain in domains:
        sys.stdout.write('%s\n' % domain)
        sys.stdout.flush()

if __name__ == '__main__':
    main()
