#!/usr/bin/env python
import os
import shutil

import logging
# __name__ isn't very exciting / informative in a standalone script
logger = logging.getLogger('style')


def walk(root):
    # flatten into just all the full filepaths
    for dirpath, dirnames, filenames in os.walk(root):
        for filename in filenames:
            yield os.path.join(dirpath, filename)


def walkall(roots):
    for root in roots:
        if os.path.isdir(root):
            for filepath in walk(root):
                yield filepath
        else:
            yield root


def seek_to_beginning_of_final_whitespace(fp, max_offset=None):
    # jump to EOF
    fp.seek(0, 2)
    if max_offset is None:
        max_offset = fp.tell()
    # find location of last non-whitespace character by starting at the end and working backward
    for offset in range(1, max_offset):
        # if the second argument of seek is 2, first argument is relative to the end of the file
        fp.seek(-offset, 2)
        char = fp.read(1)
        if not char.isspace():
            # logger.debug('Returning with %s at %d', char, fp.tell())
            # we just read over the last non-whitespace character, so the
            # current file position is now at the first of the final whitespace
            return


def ivars(obj, private=False):
    for name, value in vars(obj).items():
        if private or not name.startswith('_'):
            yield name, value


class MethodRunner(object):
    @classmethod
    def __run__(cls, arg):
        for method_name, method_callable in ivars(cls):
            result = method_callable(arg)
            logger.debug('%s.%s(%s) => %s', cls.__name__, method_name, arg, result)
            yield method_name, result


class Test(MethodRunner):
    '''
    Each Test.method returns a truthy value,
    for example, the number of errors (a positive integer), or True,
    if the given file violates the test.
    '''
    def trailing_whitespace(filepath):
        errors = 0
        with open(filepath) as fp:
            for lineno, line in enumerate(fp, 1):
                if line.rstrip('\n').endswith((' ', '\t')):
                    errors += 1
                    logger.warn('%s:%d: trailing whitespace', filepath, lineno)

        return errors

    def single_newline_at_eof(filepath):
        with open(filepath) as fp:
            seek_to_beginning_of_final_whitespace(fp)
            # fp is now sitting at the beginning of the final whitespace, if any, in the file.
            #   if there is none, fp.tell() == size
            # the rest of the file should be a single newline:
            return fp.read() != '\n'

    # @classmethod
    # def __run__extra(cls, arg):
    #     failed = method(filepath)
    #     if failed:
    #         logger.error('%s failed %s test', filepath, check)
    #     else:
    #         logger.debug('%s passed %s test', filepath, check)


class Fix(MethodRunner):
    def trailing_whitespace(filepath):
        # use a temporary file so we don't lose anything if it breaks
        filepath_tmp = filepath + '.tmp'
        with open(filepath, 'r') as file_in, open(filepath_tmp, 'w') as file_out:
            for line in file_in:
                file_out.write(line.rstrip() + '\n')
        # copy metadata from the original before we write over it
        shutil.copystat(filepath, filepath_tmp)
        # and a simple rename to finalize the changes
        os.rename(filepath_tmp, filepath)

    def single_newline_at_eof(filepath):
        # much the same as
        with open(filepath, 'a+') as fp:
            seek_to_beginning_of_final_whitespace(fp)
            # truncate first, since write will otherwise trigger jumping to the end of the file
            # from the file.truncate documentation:
            #   Size defaults to the current file position, as returned by tell()
            fp.truncate()
            fp.write('\n')


action_classes = dict(test=Test, fix=Fix)

def main():
    import argparse
    parser = argparse.ArgumentParser(description='Test or apply styles',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('action', choices=action_classes, nargs='?', default='test', help='Action to perform')
    parser.add_argument('files', nargs='*', default=['.'], help='Files / directories to read')
    parser.add_argument('-v', '--verbose', action='store_true', help='Print extra information')
    parser.add_argument('-q', '--quiet', action='store_true', help='Print less information (overrides --verbose)')
    opts = parser.parse_args()

    level = logging.WARN
    if opts.verbose:
        level = logging.DEBUG
    if opts.quiet:
        # quiet trumps verbose
        level = logging.ERROR

    # DEBUG=10, WARN=30
    logging.basicConfig(format='%(levelname)-8s %(message)s', level=level)

    ActionClass = action_classes[opts.action]

    # log current settings
    # logger.debug("%sing: %s with %s", opts.action, ', '.join(opts.files), ActionClass)

    for filepath in walkall(opts.files):
        # logger.debug('Calling %s on %s', ActionClass.__run__, filepath)
        for method_name, result in ActionClass.__run__(filepath):
            if result:
                logger.error('%s.%s(%s): %s', ActionClass.__name__, method_name, filepath, result)

if __name__ == '__main__':
    main()
